# generate_stubs.py
import os
from typing import Literal, overload, Any
import carla

# ---------------------- helpers ----------------------
def pyType(attr: carla.ActorAttribute) -> str:
    t = attr.type
    if t == carla.ActorAttributeType.Bool:
        return "bool"
    if t == carla.ActorAttributeType.Int:
        return "int"
    if t == carla.ActorAttributeType.Float:
        return "float"
    if attr.recommended_values:
        vals = ", ".join(repr(v) for v in attr.recommended_values)
        return f"Literal[{vals}]"
    return "str"

def classNameFromBpId(bpId: str) -> str:
    # "sensor.lidar.ray_cast_semantic" -> "SensorLidarRayCastSemanticStub"
    parts = bpId.replace("-", "_").split(".")
    camel = "".join(p.title().replace("_", " ").title().replace(" ", "") for p in parts)
    return f"{camel}Stub"

def fileStemFromBpId(bpId: str) -> str:
    # "sensor.camera.rgb" -> "sensor__camera__rgb_stub"
    return bpId.replace(".", "__").replace("-", "_") + "_stub"

def pyPath(outDir: str, stem: str) -> str:
    return os.path.join(outDir, f"{stem}.py")

# --------------- per-blueprint: .py with overloads ---------------
def writePerBlueprintModule(world: carla.World, bpId: str, outDir: str) -> str:
    bp = world.get_blueprint_library().find(bpId)
    className = classNameFromBpId(bpId)
    stem = fileStemFromBpId(bpId)

    lines: list[str] = [
        '"""',
        'DO NOT EDIT.',
        'This stub file was autogenerated.',
        'Do not edit by hand.\n'
        '"""\n',
        "from __future__ import annotations",
        "from typing import overload, Literal, Any",
        "try:",
        "    import carla",
        "except Exception:",
        "    carla = None  # type: ignore",
        "",
        f"class {className}:",
        "    def __init__(self, sensor_bp: 'carla.ActorBlueprint | None' = None) -> None:",
        "        self.sensor_bp = sensor_bp",
        "",
    ]

    # typed overloads
    for attr in bp:
        name = attr.id
        lines.append("    @overload")
        lines.append(f"    def set_attribute(self, name: Literal[{name!r}], value: {pyType(attr)}) -> None: ...")

    # runtime implementation + camelCase wrapper
    lines += [
        "    def set_attribute(self, name: str, value: Any) -> None:",
        "        if self.sensor_bp is None:",
        "            return",
        "        # CARLA expects string values for blueprint attributes",
        "        self.sensor_bp.set_attribute(name, str(value))",
        "",
        "    def setAttribute(self, name: str, value: Any) -> None:",
        "        self.set_attribute(name, value)",
        "",
        "__all__ = [",
        f"    '{className}',",
        "]",
        "",
    ]

    os.makedirs(outDir, exist_ok=True)
    path = pyPath(outDir, stem)
    with open(path, "w") as f:
        f.write("\n".join(lines))
    return path

# ------------------ combined: .py with overloads -----------------
def writeCombinedModule(world: carla.World, bpIds: list[str], outPathPy: str) -> None:
    lines: list[str] = [
        '"""',
        'DO NOT EDIT.',
        'This stub file was autogenerated.',
        'Do not edit by hand.\n'
        '"""\n',
        "from __future__ import annotations",
        "from typing import overload, Literal, Any",
        "try:",
        "    import carla",
        "except Exception:",
        "    carla = None  # type: ignore",
        "",
        "class AllSensorsAttributeStub:",
        "    def __init__(self, sensor_bp: 'carla.ActorBlueprint | None' = None) -> None:",
        "        self.sensor_bp = sensor_bp",
        "",
    ]

    seen: set[tuple[str, str]] = set()
    # accumulate unique (name, type) overloads across chosen sensors
    for bpId in bpIds:
        bp = world.get_blueprint_library().find(bpId)
        for attr in bp:
            name = attr.id
            typ = pyType(attr)
            key = (name, typ)
            if key in seen:
                continue
            seen.add(key)
            lines.append("    @overload")
            lines.append(f"    def set_attribute(self, name: Literal[{name!r}], value: {typ}) -> None: ...")

    lines += [
        "    def set_attribute(self, name: str, value: Any) -> None:",
        "        if self.sensor_bp is None:",
        "            return",
        "        self.sensor_bp.set_attribute(name, str(value))",
        "",
        "    def setAttribute(self, name: str, value: Any) -> None:",
        "        self.set_attribute(name, value)",
        "",
        "__all__ = ['AllSensorsAttributeStub']",
        "",
    ]

    os.makedirs(os.path.dirname(outPathPy), exist_ok=True)
    with open(outPathPy, "w") as f:
        f.write("\n".join(lines))

# --------------------- package __init__ (.py) ---------------------
def writeInits(stubsDir: str, modulePaths: list[str]) -> None:
    lines = ["# Auto-generated by generate_stubs.py. Do not edit by hand", "from .all_sensors_stub import AllSensorsAttributeStub"]
    for p in modulePaths:
        mod = os.path.splitext(os.path.basename(p))[0]
        lines.append(f"from .{mod} import *")
    with open(os.path.join(stubsDir, "__init__.py"), "w") as f:
        f.write("\n".join(lines) + "\n")

# --------------------------- main ---------------------------
if __name__ == "__main__":
    client = carla.Client("localhost", 2000); client.set_timeout(5.0)
    world  = client.get_world()

    chosen = [
        "sensor.camera.rgb",
        "sensor.camera.depth",
        "sensor.camera.semantic_segmentation",
        "sensor.camera.instance_segmentation",
        "sensor.camera.optical_flow",
        "sensor.camera.dvs",
        "sensor.camera.normals",
        "sensor.lidar.ray_cast",
        "sensor.lidar.ray_cast_semantic",
        "sensor.other.radar",
        "sensor.other.imu",
        "sensor.other.gnss",
        "sensor.other.lane_invasion",
        "sensor.other.obstacle",
        "sensor.other.collision",
        "sensor.other.rss",
    ]

    stubsDir = "./utils/stubs"
    # 1) Combined module (.py) with overloads
    writeCombinedModule(world, chosen, os.path.join(stubsDir, "all_sensors_stub.py"))

    # 2) Per-blueprint modules (.py) with overloads
    modulePaths = [writePerBlueprintModule(world, bpId, stubsDir) for bpId in chosen]

    # 3) Package __init__.py
    writeInits(stubsDir, modulePaths)

    print(f"Runtime stub modules generated in {stubsDir}")
